
Тема Многопоточность

	Процессы состоят из потоков.
	Процессы стараются изолировать друг от друга,
		а потоки наоборот должны обмениваться данными между собой.
	
	Процесс наподобие "РЕКИ", а поток это ручейки втекающие и вытекающие.
	
Первый способ взаимодействия потоков проэкт ProcessStart

Второй способ взаимодействия SocetServer и SocetClient
		В командной строке командой: "netstat -a" показывает состояние подключений
		
		
	Создание потока:
		1) Способ - создать класс наследующий от Thread
			и переопределить в нем метод run()
			Потом для созданного обьекта нашего класса вызвать метод start()
			
		2) Создать класс MyClass реализующий интерфейс Runnable
			и в нем переопределить в нем метод run()
			Создаем обьект  Thread(new MyClass())в параметре конструктора создаем обьект класса  реализующего Runnable
			start();
			
		3) Анонимным классом
			Создаем обьект класса Thread  в качестве параметра указываем анонимный класс реализуюший Runnable
				описваем метод run()
				start();
				
		4) Лямбда выражением
		
	Для первых двух(1,2) способов можно передавать параметры через конструкторы
	Для вторых двух(2,3) параметры передаются через финализированные локальные переменные 
	
	
Потоки имеют состояние getState() isAlive

Потоки можно сделать демонами setDeamon(true)
	Важное свойство:
			Если в процессе работы программы остались только демоны,то
				VM завершает все потоки.
				
		Для прерывания или остановки потоков:		
			Потоки имеют не безопасные методы stop() suspend() их лучше не использовать
			
			Лучше использовать методы interupt() - устанавливает флажок, interrupted() - возвращает флажок и сбрасывает его.  isInterrupted() возвращает "флажок" но не сбрасывает его.
				Установка interupt() флажка делается в исполняемом коде,а
					проверка interrupted(), isInterrupted() в теле метода run().
					
					
Тема СИНХРОНИЗАЦИЯ

	Допустим нам нужно,чтобы главный поток закончил выполняться последним
		используем join(). Обязательно после start()
		
	ВАЖНО компилятор и процессор могут оптимизировать код(), например:
		int a=5;
		int b=5;
		a=10;
		
		этот код на самом деле будет выполнен так:
		int a=5;
		a=10;
		int b=5;
		
		Потому,что если результат один и тот же, то нет смысла прескакивать с адреса а на b потом опять на a
		
		Но в cлучае join() нам гарантируется что весь код выше выполнен(это называется барьером) 
		
Synchronized(some object){} обьект синхронизации может быть любой
	1. способ(синхронизяция обьектом синхронизации)
		Когда поток доходит до блока synchronized(...){},то
		это называется захватом монитора.
		1) Если монитор не захвачен, то поток захватывает его и выполняет блок sinchronized
		2) Если монитор захвачен, то поток переходит в состояние блокировки и ждет пока освободится монитор
		
	Обычно обьект синхронизации выбирается такой, чтобы потоки его и изменяли, но это не обязательно
	
	ВНИМАНИЕ(volatile):
		обект синхронизации может быть изменен не только в в наших синхронизированнных потоках,
			но и в другом месте.
		synchronized захватывает не сам обьект, а монитор обьекта
		Поэтому перед обьектом синхронизации обычно указывается ключевое слово volatile-оно указывает, что значение может изменяться не только в наших потоках
		
	2.способ(синхронизация в методах)
		Указать sinchronized метод у класса, обьекты которого мы хотим изменить
		Потом этот метод вызывать в потоках.
		
		
	Коллекции в основном не потокобезопасные, кроме HashTable and Vector
	
	3.способ (синхронизация по событиям)
		notify()
		wait() - ждет и освобождает мониторы